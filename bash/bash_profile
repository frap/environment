# From the bash manual:
# When Bash is invoked as an interactive login shell, or as a non-interactive 
# shell with the --login option, it first reads and executes commands from the
# file /etc/profile, if that file exists. After reading that file, it looks for
# ~/.bash_profile, ~/.bash_login, and ~/.profile, in that order, and reads and
# executes commands from the FIRST one that exists and is readable. The 
# --noprofile option may be used when the shell is started to inhibit this
# behaviour.

# linux loads bash_profile on login and bashrc for xterm (aka already logged in)
# Mac OS X terminal loads .bash_profile on starting Terminal :(

# So we set all login information in .bashrc
# We need to do two things here:

# 1. Ensure ~/.config/bash/env gets run first
. ~/.config/bash/env

# 2. Prevent it from being run later, since we need to use $BASH_ENV for
# non-login non-interactive shells.
# We don't export it, as we may have a non-login non-interactive shell as
# a child.
BASH_ENV=

# 3. Join the spanish inquisition. ;)
# so much for only two things...

# 4. Run ~/.config/bash/login
. ~/.config/bash/login

# 5. Run ~/.config/bash/interactive if this is an interactive shell.
if [ "$PS1" ]; then
    . ~/.config/bash/interactive
fi


# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
__conda_setup="$('/opt/homebrew/Caskroom/miniforge/base/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/homebrew/Caskroom/miniforge/base/etc/profile.d/conda.sh" ]; then
        . "/opt/homebrew/Caskroom/miniforge/base/etc/profile.d/conda.sh"
    else
        export PATH="/opt/homebrew/Caskroom/miniforge/base/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<

